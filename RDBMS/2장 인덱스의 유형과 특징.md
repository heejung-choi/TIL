# 새로쓴 대용량 데이터베이스 솔루션 책 내용 정리
## 1부 액세스 영향 요소의 이해

## 2장 인덱스의 유형과 특징
인덱스는 목차나 색인의 개념이다. 일반적으로 인덱스를 키(key) 라는 생각으로 접근을 하고 있다. 엄밀한 의미에서 이들의 개념은 확실히 다르다. 인덱스는 단순하게 색인이라는 개념에 앞서 옵티마이져가 실행계획을 수립할 때 최적의 경로를 찾도록 하는 '전략적 요소'라는 시각에서 접근해야 한다.

### 2.1 B-tree 인덱스
### 2.1.1 B-tree 인덱스의 구조
이 구조는 말 그대로 나뭇가지의 모습과 유사하다. 줄기에서 차례로 가지가 뻗어 나가고 마지막 가지에 잎사귀가 달려있는 유형과 아주 흡사하다. 테이블의 로우가 어떤 위치에 있든 동일한 처리방법과 속도로 접근할 수 있다는 것은 이 인덱스가 가지는 가장 큰 특징이다. 

이 인덱스의 구조에도 나무처럼 가지에 해당하는 브랜치블록(Branch block)과 잎사귀에 해당하는 리프블록(Leaf block)이 있다. 가지의 깊이가 속도에 영향을 줄 수는 있지만 거의 무시할 수 있는 수준이다. 100건의 로우를 가진 테이블이나 100만건의 로우를 가진 테이블이나 한건을 액세스하는 속도는 거의 같다는 것을 의미한다. 범위처리를 할 때에 더욱 그 차이는 없어진다. 인덱스를 경유하여 데이터를 액세스 할 때 루트 블록에서 출발해서 브랜치 블록을 추적하여 리프 블록을 찾는다.


### 2.1.3 리버스키 인덱스
여기서 말하는 리버스는 역순이 아니라 어떤 컬럼값의 각 바이트의 위치를 역전시키는 것을 말한다. 다시 말해 만약 '12345'가 있다면 이 값의 리버스는 '54321'이 된다.  그러나 이로 인해 저장되는 인덱스 순서는 우리가 원하는 순서가 아니다. 리버스키 인덱스에서는 다음 스캔을 했을 때 우리가 원하는 범위의 값을 찾을 수 없기 때문에 논리적으로 이미 수행이 불가능하다. 그러나 인덱스를 전체 스캔하는 처리는 가능하다. 따라서 리버스 키 인덱스를 제한적으로 활용하게 하였다. 그러나 랜덤 엑세스의 효율은 분명이 향상된다.


### 2.2. 비트맵 인덱스
비트맵 인덱스는 최소 단위인 비트를 이용하여 컬럼값을 저장하고 이를 이용하여 ROWID를 자동으로 생성하는 인덱스의 한 방법이다. 비트를 직접 관리하기 때문에 저장공간이 크게 감소하고 비트별로 각종 연산을 수행함으로써 기존에 인덱스가 해결할 수 없었던 문제를 해결하게 되었다.  검색하기에 용이하지만 생성과 유지에 대한 비용 때문에 주로 데이터웨어하우스에서만 활용되고 있다.


### 2.2.1 비트맵 인덱스의 탄생배경 (B-Tree 인덱스의 문제점)
B-Tree 인덱스에서는 실제 컬럼값을 인덱스에도 보관하고 있어야 하고, 컬럼값의 분포도가 좁아야 한다. 분포도가 넓으면 오히려 전체 테이블을 모두 액세스하는 것보다 불리할 수 있다. 이를 해결하기 위해 결합인덱스를 사용하였다. 그러나 결합인덱스의 경우 조건을 사용하지 않는 컬럼이나 '=' 조건이 아닌 경우가 있으면 액세스 효율이 크게 저하되는 문제를 가지고 있었다. 이를 위해 특정 컬럼은 여러개의 인덱스에 중복으로 구성하기도 하였다.

그리고 더 심각한 문제는 카디널리티가 매우 낮은 다수의 디맨전들이 다양한 구조로 결합을 할 때이다. 이런 문제를 B-tree 인덱스로 해결하려면 엄청난 개수의 인덱스를 동원해야 한다. 또한 B-Tree의 경우 'NULL','NOT','OR'를 포함하고 있는 경우에는 인덱스로서의 가치를 발휘할 수 없다는 것이다. 처리범위만 일부 줄이고 체크조건의 역할만 할 수 있는데 체크조건의 역할은 테이블에서 액세스 할량을 줄이는데 기여하지 못한다.

비트맵 인덱스는 위에서 기술한 부분에 대한 대안을 제시한다. 독립적으로 구성되어 있는 각각의 비트맵 인덱스가 필요한 순간에 서로 조합하여 목적을 달성할 수 있다는 특성은 매우 많은 부분에 영향을 미친다.

### 2.2.2 비트맵 인덱스의 구조와 특성
비트맵 인덱스는 루트블록이나 브랜치블록은 B-Tree 인덱스와 같은 구조로 되어있다. 그러나 리프블록은 아래에서 보는 것과 같이 비트맵으로 구성되어 있다.

<img src="https://github.com/heejung-choi/TIL/assets/58652391/dc0f27e9-26f0-4541-919f-41f99074eb9b" width="400" height="250"/>

비트맵 인덱스는 B-tree 인덱스처럼 분포도가 높지 않은 컬럼들을 굳이 결합할 필요가 없다. 각 비트맵 인덱스에서 추출한 결과를 이용해 비트맵 연산으로 처리할 수 있기 때문이다. 비트를 OR로 연산하면 1이 어느 한쪽에만 있어도 1이 되고 AND로 연산하면 어느 한쪽이라도 0이 있으면 결과는 0이다.

그러나 '='이 아닌 LIKE, BETWEEN, >, < 등이 사용되면 추출할 비트가 명확하지 않기 때문에 적합하지 않다. 이러한 이유로 비트맵인덱스는 데이터웨어하우스 업무에서 주로 활용된다.

### 2.2.3 비트맵 인덱스의 액세스
비트맵 인덱스를 경유하여 테이블을 엑세스할 때에는 AND 연산하여 조건에 맞는 것들만 색출한다. 또한 그 결과를 ROWID로 변환해 테이블을 액세스한 다음 집계를 했다는 것을 나타내고 있다.


### 2.3 함수기반 인덱스
### 2.3.1 함수기반 인덱스의 개념 및 구조
함수기반 인덱스란 테이블의 컬럼을 가공한 논리적 컬럼을 인덱스로 생성한 것이다. 함수기반 인덱스는 함수나 수식으로 계산된 결과에 대해 B-tree 인덱스나 비트맵 인덱스를 생성할 수 있다. 산술식, 사용자 지정 함수, SQL 제공함수, 패키지 등이 가능한s데 SUM AVG 등의 그룹함수는 사용할 수 없다. 이러한 함수들은 테이블 로우 단위가 아닌 논리적으로 생성된 로우이기 때문이다.
