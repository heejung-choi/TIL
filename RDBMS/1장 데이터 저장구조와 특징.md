# 1부 액세스 영향 요소의 이해

## 1장 데이터 저장구조와 특징
### 1.1. 테이블과 인덱스의 분리형
### 1.1.1. 분리형 테이블의 구조


테이블스페이스: 논리적인 저장공간을 말함 ex) 내 소유의 토지, 건물을 신축하기 위해 마련한 부지
세그먼트: 테이블스페이스를 용도별로 나눈 것으로, 대지 위에는 아파트와 같은 단위건물이나 구축물이 들어설 수 있듯이 세그먼트에는 데이터 오브젝트가 들어올 수 있다.

파티션된 테이블의 각 파티션이 서로 다른 테이블스페이스에 존재하는 경우에는 당연히 여러 테이블스페이스에 걸처 저장될 수 있다. 하지만 개별 파티션이나 파티션 되지 않는 테이블들은 반드시 하나의 테이블스페이스에만 존재해야 한다. 이말은 곧 데이터파일의 식별자를 전체에 유일한 절대번호가 아닌 테이블스페이스 내에서 상대적인 번호를 붙이더라도 하나의 오브젝트 내에서는 충분히 유일하게 식별될 수 있다는 것을 의미한다. 이것은 로우식별자를 보다 짧게 구성할 수 있도록 하는 매우 중요한 의미를 가진다.

* ROWID: '오브젝트번호+데이터파일번호(테이블스페이스당 일련번호)+블록번호+슬롯번호' 로 구성

'주소'는 논리적인 값이기 때문에 테이블에 어디에도 ROWID는 저장되어 있지 않다. 인덱스에 존재한다.우편함에는 호수만 나와있을 뿐 사람에 대한 정보는 없는 것처럼 슬롯에는 슬롯번호만 있지만 그 속에는 로우의 위치번호가 들어있다. 즉, ROWID에는 로우의 구체적인 정보가 아닌 위치가 들어있는 방(슬롯)의 정보만 존재하고 있다는 것이다. 다시 말해 로우의 위치가 아무리 이동하더라도 ROWID는 결코 변하지 않는 다는 것을 의미한다. 

로우의 이동에 따라 ROWID가 변경된다면 모든 인덱스를 수정해야 하는 번거로움이 발생한다. 로우가 한 조각으로 저장될 수 있는 위치로 이동했을 때 해당 슬롯에 있는 기존의 위치값을 새로운 위치값으로 바꾸어주기 때문에 ROWID의 변경 없이도 로우의 위치 이동이 자유롭다. 그러나 계속적인 이동이 발생하면 사용할 수 없는 작은 조각들이 발생하게 된다. 이로 인해 이어진 조각이 없어 저장이 불가능하게 될 때 자동으로 블록의 로우들을 재구성하는 응축작업이 이루어진다. 이를 발생시키지 않게 하기 위해서는 여유공간을 지정해 두는것이 좋다. 우리가 아무리 여유공간을 충분히 부여했다고 해도 너무 커졌다면 다른 블록으로 매꿀 수 밖에 없다. 이렇게 되면 ROWID를 변경할 수 밖에 없는데, 변경하지 않기 위해 과거의 주소로 나를 찾아왔을 때 거기에 내가 옮긴 주소를 넣어두는 방법인 '로우의 이주'를 사용한다.

체인: 여러 블록에 걸쳐 데이터가 존재하다는 점에서 이주와 유사하지만 본질적인 차이가 있다. 어떤 로우의 길이가 한 블럭을 넘는다면 여러 블록을 연결해서 저장해야 하는데 이것을 '체인이 발생했다'라고 한다.


### 1.1.2. 클러스터링 팩터
분리형 테이블의 구조가 가지는 최대의 특징은 데이터의 값과 무관하게 임의의 위치에 저장한다는 것이다. 따라서 찾고자 하는 값이 얼마나 가까운 위치에 모여있느냐에 따라 성능이 차이날 수 있다. 인덱스의 컬럼값으로 정렬되어 있는 인덱스 로우의 순서와 테이블에 저장되어 있는 데이터 로우의 위치가 얼마나 비슷한 분포로 저장되어있느냐의 정도를 나타내는 것이 클러스터링 팩터이다.

클러스터링 팩터가 좋은 인덱스로 액세스를 하면 많은 로우를 액세스 하더라도 보다 적은 블록을 액세스하게 되어 효율적이다. 이것은 이왕이면 자주 넓은 범위를 액세스해야 하는 경우에 유리하도록 저장을 해두는 것이 무척 중요하다는 것을 의미한다.

클러스터링팩터를 향샹시키는 전략
	- 소극적방법: 데이터 저장형식에 강제적인 제약 없이 임의의 위치에 저장하는 방식
	- 추가적인 비용이 들어가더라도 원하는 형태로 데이터를 저장하도록 테이블을 재생성하는 것이다. (병렬처리 문제가 발생할 수 있음)\
	
### 1.1.3 분리형 테이블의 액세스 영향요소
가) 넓은 범위의 액세스 처리에 대한 대처방안
분리형 구조에서는 대량의 처리를 해결하는 방법(병렬처리, 파티션, 각종 인덱스기법)등의 구조를 사용해야 한다.

#### 테이블의 크기에 다른 대처방안
* 소형테이블: 소량의 데이터를 가진 경우 그리 많지 않은 블록에 흩어져 있을 것이고 부하가 그리 크지 않다. 빈번한 액세스를 일으키기 때문에 아주 미묘한 크기조차 크게 나타날 수 있는 중대한 액세스 형태라면 적극적인 방법(인덱스 일체형테이블, 클러스터링형구조)를 적용할 수 있지만 특별한 케이스가 아니라면 조치를 하지 않아도 무방하다.

* 중형테이블: 등록시에는 부담이 되더라도 좋은 액세스를 위해서는 찾기 좋은 형태로 저장해두는 것이 바람직하다. 그러나 특정한 모양으로 저장한다고 해서 모든 경우가 해결되는 것은 아니다. 특정 액세스 형태에서만 효율을 얻을 수 있다. 따라서 가장 중요한 액세스 형태를 선정하고, 당위성을 찾아내어 이를 반영해야 할지 결정한다.

* 대형테이블
1) 단순저장형 개념 : 로그저장형으로 특별한 경우에 특정 액세스형태로 읽거나 대량을 스캔하는 형태로 주로 사용, 신속한 저장 요구 -> 분리형이 가장 적절한 형태이며 대량의 데이터가 증가되므로 파티션과 같은 조치가 필요하다.

2) 고객테이블과 같이 대량의 데이터가 모여있지만, 랜덤액세스가 주로 발생하며 다양한 액세스를 갖지 않는 경우: 분리형 구조가 가장 적절, 파티션이나 클러스터링을 해도 그리 큰 혜택이 없는 경우이다.

3) 매출테이블과 같이 대량의 데이터가 지속적으로 증가, 다양한 액세스를 가지는 경우: 시스템에 지대한 영향을 미치고, 데이터의 관리적인 측면이나 액세스에 대한 부담도 만만치 않다. 따라서 파티션, 인덱스 전략적 구성, SQL 실행계획 최적화시키는 방법을 통해 해결해야 한다. 

나) 클러스터링 팩터 향상 전략

분리형 구조와 같이 정해지지 않은 순서로 저장된다는 것은 아무렇게 저장해도 괜찮다는 의미이기도 하지만 의도적으로 우리에게 유리한 형태로 저장하는 것도 가능하다는 의미가 되기도 한다. 그러나 분리형 구조는 저장시에 강제로 제어할 수 있는 방법이 없다. 가능한 방법은 이미 저장되어 있는 데이터의 응집도를 높여주는 수 밖에 없다. 즉, 주기적으로 테이블을 재생성 시켜주는 방법을 사용하자는 것이다.

일반적으로 수행속도의 향상을 목적으로 테이블을 재생성하고 있는데 대부분 응집도를 높이기 위한 목적이아니라 체인을 감소시키고 블록내 데이터의 저장율을 높여 불필요한 I/O를 줄이기 위해 사용하고 있다. 그러나 테이블 재생성시 가장 고려해야 할 요소는 새롭게 저장될 데이터들이 가장 유리한 형태로 저장되도록 하는 것이다.(자주 범위처리 하는 컬럼으로 정렬)  또한 재생성 테이블에 데이터를 저장할 때 관련된 인덱스를 모두 제거하거나 비활성 시키는 것이 좋다. 인덱스를 생성한 채로 대량의 데이터를 저장하면 성능이 나빠지기 때문이다.


### 1.2. 인덱스 일체형 테이블
가장 일반적으로 사용하는 B-Tree 인덱스는 '인덱스컬럼 + ROWID'로 구성되어 있다. 이러한 구조로 인해 B-Tree 형태의 인덱스를 경유하여 테이블을 액세스 할 경우에는 항상 두번의 논리적인 액세스가 발생하게 된다. 한번은 인덱스 세그먼트를 액세스 하는 것이고, 또 한 번은 여기서 얻은 ROWID를 이용하여 데이터세그먼트를 액세스 하는 것이다. 대부분의 경우에는 두번의 액세스가 발생해도 문제가 되지 않지만 빈번하게 사용되거나 대량의 범위를 자주 스캔하는 경우에는 부담이 될 수 있다.

테이블과 인덱스가 일체형으로 되어있다는 것은 인덱스와 다른 일반컬럼들이 모두 같은 위치에 저장되는 형태를 말한다.


### 1.2.2 일체형 테이블의 구조 및 특징
기존의 B-Tree 인덱스와 달리 ROWID를 가지고 있지 않다. 테이블과 인덱스를 모두 가지고 있기 때문에 ROWID를 가지고 데이터를 액세스 할 필요가 없다. 이 구조가 가진 장점은 인덱스가 경유하지 않기 때문에 한번의 논리적인 액세스가 줄어들었다는 것과, 넓은 범위의 스캔일 때 확실하게 성능이 좋아진다. 그러나 우리가 이 구조를 많이 활용하지 않는 주된 이유 중에 하나는 로우의 길이의 변화에 따라 발생할 수 있는 오버플로우를 두려워 하기 때문이다. B-Tree는 대부분 나중에 NULL값이 채워진다거나 길이가 크게 변하는 일이 적기 때문에 문제가 되지 않지만 일체형 구조의 경우에는 일반커럼을 모두 보유하고 있어 길이가 증가할 확률이 높아진다.


### 1.2.3. 논리적 ROWID와 물리적주소
분리형테이블은 인덱스의 분할이 발생해도 ROWID는 변하지 않지만 일체형은 자신이 곧 테이블이므로 인덱스의 분할에 의한 로우의 이동에 따라 ROWID가 변할 수 있다. 따라서 영구적인 어드레스를 가질 수 없고, 로우의 이동에 따라 ROWID가 변할 수 있다. 이를 해결하기 위해 '논리적 ROWID'라는 개념을 도입하였다.

일체형테이블의 ROWID는 일반적인 ROWID와 유사한 구조와 역할을 하고 있으나, 이 물리적인 주소는 인덱스 로우가 생성될 때 만들어져서 키 분할에 의해 데이터 블록의 위치가 달라져도 변경되지 않는다. 이 값으로 해당 로우를 찾아가면 원래의 로우는 다른 블록으로 이동되고, 거기에는 다른 로우가 존재할 수 있다는 것이다.

이 값은 로우가 저장된 물리적인 주소를 나타낸다고 하기보다는 그 로우가 존재할 가능성 높은 주소를 나타내기 때문에 이것을 'PHYSICAL GUESS'혹은 'GUESS'라고 한다. 데이터를 액세스 할 때 부정확할 확률이 높다고 판단되면 액세스를 시도하지도 않는다. 이와 같은 물리적 위치 정보와 기본키가 상호작용을 하여 논리적으로는 완벽한 ROWID 역할을 하게 된다. 따라서  '논리적 ROWID'라고 하는 것이다. 물리적인 위치정보가 정확하다면 일반적인 인덱스 스캔과 동일하지만 적중률이 낮다면 기본키를 사용하는 것이 더 효율적이다.

일체형 구조는 다음과 같은 경우에만 적용하는게 바람직하다
-> 전자카탈로그 테이블, 키워드검색용 테이블, 코드성 테이블, 색인 테이블, 공간 정보 관리용 테이블, 대부분 기본키로 검색되는 테이블 등


### 1.2.4. 오버플로우 영역
우리가 일체형 테이블을 생성할 때 부여한 이동에 대한 임계치에 도달하면 'INCLUDING'절에서 저장한 컬럼 이후의 컬럼들은 모두 오버플로우 영역에 저장된다. 그러므로 테이블 생성 시에 컬럼을 지정할 때 순서를 잘 결정할 필요가 있다. 또한 액세스의 부담을 줄이기 위해서는 인덱스와 함께 저장될 길이를 줄이기, 적재할 컬럼 줄이기, 오버플로우 영역에 상대적으로 빈번하게 액세스 되지 않는 것들을 옮겨두는 방법 등을 사용해야 한다.

### 1.3 클러스터링 테이블
분리형은 대량의 데이터를 범위처리해야 하는 경우에 많은 랜덤을 발생시키는 부담이 있었다. 일체형은 특정한 액세스에서는 랜덤이 없어졌지만 다양한 액세스 형태가 나타나면 오히려 더 많은 부담을 가져오므로 대용량의 데이터에서는 적용하기 어렵다. 

물론 다양한 형태의 인덱스를 활용하면 상당한 개선을 이룰 수 있겠지만 그것도 최종적으로 찾고자 하는 절대 범위가 적을 때 가능하다. 수행속도의 문제를 해결하기 위해서는 대량의 처리를 효율적으로 할 수 있는 방법을 찾아야 한다. 대부분 다수의 인덱스 지정, 집계용 테이블의 추가, 다른 테이블의 컬럼 복사 시켜두는 중복화 등으로 해결하려 하지만 이는 또 다른 문제를 야기시킨다. 문제를 효율적으로 개선하기 위한 방법들은 다양하고 상황에 따라 달라지지만, 가장 큰 활용가치를 가지고 있는 것은 클러스터링이다.


### 1.3.1 클러스터링 테이블의 개념
클러스터는 테이블이나 인덱스처럼 저장공간을 가지고 있는 하나의 오브젝트이다. 그러나 테이블이 인덱스보다 상위개념이듯이 클러스터는 테이블의 상위개념이다. 클러스터로 생성된 오브젝트 내에 테이블이 생성되는 것이다.

* 다중테이블 클러스터링의 예시
어떤 지역에 여러 공장들이 있는데 이들은 서로 원재료를 주고받아야 하므로 도로가 복잡하게 연결되어 있다. 이 경우 멀리 떨어져 있는 공장간에 재료가 빈번하게 공급되어야 한다면 많은 비용이 소모되고 생산성이 저하될 것이다. 따라서 자주 운송이 발생하는 두 공장을 인접한곳에 배치(같은 클러스터 내에 생성)하여 콘베이어 벨트를 설치한다면 엄청난 연결 효율을 얻을 것이다. 이러한 목적으로 테이블을 클러스터 하는 방법을 다중테이블 클러스터링이라고 한다.

* 단일테이블 클러스터링의 예시
어떤 창고에 수만은 부품들이 무질서하게 보관(분리형 테이블 구조)되어 있고, 이를 찾아내기 위해 부품들의 위치를 알 수 있는 목록(index)가 있다고 하면  소량의 부품을 찾는 것은 큰 부담이 없겠지만 대량의 부품을 일시에 찾는다면 많은 부담이 발생할 것 입니다. 이러한 문제를 해결하기 위해 창고내부를 섹터(cluster)로 나누고 각 섹터에는 동일한 유형의 부품(동일한 Cluster Key를 갖는 row)을 보관한다. 이러한 방식은 대량의 동일한 부품을 찾을 때 해당 섹터를 찾으면 쉽게 대량의 부품을 싼 단가로 찾을 수 있다. 이처럼 댜령의 범위를 효율적으로 액세스 하기 위해 클러스터링을 하는 방법을 단일테이블 클러스터링이라 한다.

클러스터에 데이터를 저장하기 위해서는 테이블 생성뿐만 아니라 클러스터 인덱스도 같이 생성되어야 한다. 클러스터링이란 어떤 정해진 컬럼값을 기준으로 동일한 값을 가진 하나 이상의 테이블의 로우를 같은 장소에 저장하는 물리적인 기법이다. 클러스터 인덱스는 일반 인덱스와 기본적으로 동일하나 일반 인덱스는 테이블의 로우마가 하나씩의 인덱스 로우를 가지지만 클러스터 인덱스는 클러스터링 컬럼의 값마다 하나씩의 인덱스 로우를 가진다.


### 1.3.2 단일테이블 클러스터링
단일테이블 클러스터링이란 지정된 클러스터에 하나의 테이블만 생성시키는 것을 말한다. 같은 클러스터 컬럼값을 가진 로우는 같은 장소에 저장되므로 넓은 범위의 데이터를 동시에 액세스하고자 할 때 주로 활용된다. 클러스터 인덱스는 클러스터키 컬럼값마다 하나씩 존재한다. 클러스터링 테이블의 각 로우 헤더에는 클러스터키 ID를 가지고 있으므로 같은 ID를 가진 로우들을 스캔함으로써 우리가 원하는 집합을 얻을 수 있게 된다. 클러스터링 값이 변경되는 경우에는 최초의 로우 위치에 이주한 ROWID를 남겨두고 본체는 모두 새로운 곳으로 이동한다 

클러스터링 개념을 이해하기 위해 클러스터링 테이블은 일반테이블의 개념이 한단계씩 높아진 것이라고 생각하면 이해가 빠르다. 하나의 단위 클러스터를 일반테이블의 로우로 생각하고, 단위 클러스터 내에 있는 로우들을 일반 테이블의 컬럼이라고 생각하면 된다. 

단일 테이블 클러스팅은 대량의 범위를 처리하더라도 랜덤 액세스를 현격하게 줄이고 스캔을 극대화 함으로써 일반 인덱스 스캔에 비해 매우 효율적인 액세스가 가능하다. 이것은 클러스터 인덱스가 일반 인덱스에 비해 뭔가 특별한 메커니즘으로 되어있기 때문인 것은 아니다. 단지 한번 클러스터 인덱스를 액세스하여 여러건의 테이블 로우를 스캔방식으로 액세스 할 수 있다는 차이가 있을 뿐이다.  따라서 단일테이블 클러스터링은 분포도가 넓어야 유리하다.


### 1.3.3 다중테이블 클러스터링
다중테이블 클러스터링이란 단위 클러스터에 두개 이상 테이블을 함께 저장하는 것을 말한다. 같은 클러스터키 컬럼값을 가진 각 테이블의 로우는 정해진 장소에 같이 저장되므로 테이블을 조인하는 속도를 향상시키고자 할 때 주로 활용된다. 클러스터 인덱스를 경유하여 클러스터를 읽고 같은 클러스터 내에서 연결작업을 수행한다. 조인할 대상이 같은 클러스터 내에 있다는 것은 연결을 위한 추가적인 액세스를 하지 않으므로 매우 효율적인 조인이 가능하다. 

과거 파일의 경우 반복컬럼을 생성시켰다. 주인이 되는 키(key)가 있고 반복되지 않은 단일필드들과 배열필드들이 혼합되어 구성된다. 먼저 키가 위치하고 이어서 단일 필드들이 위치하며 배열필드는 개념적으로는 이차원이지만 실제로는 선형적으로 나열되어 저장된다. 이 파일을 관계형DB로 설계하면 제1정규화에 의해 배열들은 별개의 테이블로 분할되어 두개의 테이블이 된다. 이들을 연결하기 위해서는 다양한 방식의 조인이 발생되는데 원래 한 레코드에 있어 같이 액세스할 수 있었던 것을 조인을 해야 하기 때문에 부담이 발생된다.

과거에는 배열 중에 몇개만 필요해도 레코드 전체를 액세스 해야 했고 특정값을 조건 검색할 수 없었다. 그러나 클러스터링 테이블은 키값이 중복해서 저장되지 않을 뿐만 아니라 한 레코드를 액세스 하듯이 효율적으로 조인을 할 수 있다. 각 테이블의 독립성이 보장되므로 자식 테이블의 특정 조건만 만족하는 로우만 읽을 수도 있다.

클러스터 인덱스는 컬럼값의 종류마다 한 건만 생성되므로 파일인 경우와 동일하게 1천만 개의 인덱스 로우가 생긴다. 레코드에 해당하는 단위 클러스터의 수 또한 1천만 개라고 할 수 잇다. 특정 레코드를 액세스 하는 경우에도 1천만 건의 인덱스 로우에서 바로 한 개의 단위 클러스터를 액세스하여 20개의 로우를 같은 장소에서 찾으므로 크게 차이가 나지 않는다. 그러나 과거에는 불가능했던 장점이 많이 추가되었다. 클러스터링 테이블은 클러스터 컬럼이 수정되면 데이터값이 수정됨으로써 추가적인 클러스터 체인블록이 발생하므로 클러스터링 효율이 감소한다. 

여러 장점이 있음에도 불구하고 실전에서는 특별한 경우에만 적용해야 한다. 특수한 관계의 연결에는 도움이 되는게 분명하지만 각 테이블의 유연성이 훼손되기 때문이다.


### 1.3.4 클러스터링 테이블의 비용
클러스터링은 관계형 데이터베이스의 최대 약점인 넓은 범위의 처리를 해결해주고 조인의 효율을 크게 높여주므로 데이터 액세스에 대해 우리에게 주는 이득은 매력적이다. 하지만 거기에 상응하는 대가가 반드시 따른다. 따라서 먼저 해결해야 할 액세스 형태를 모두 수집하고 적은 비용이 드는 인덱스로 해결할 수 있는 방안을 강구해야 하며 이들 간의 역할의 중복으로 인한 투자의 낭비가 발생하지 않도록 역할 분담을 해야 한다. 또한 클러스터링으로 인한 부하의 부담도 고려되어야 한다.


### 1.3.5 해쉬 클러스터링
해쉬 클러스터링은 어떤 의미에서 보면 클러스터링이라고 하기 보다는 인덱스를 대신하는 개념으로 볼 수도 있다. 물리적인 인덱스를 가지지 않고 해쉬값을 이용해 데이터를 액세스하려면 테이블의 데이터를 약속된 장소에 저장할 수 밖에 없다. 테이블에 데이터를 정해진 위치에 저장한다는 입장에서 보면 클러스터링의 개념이고, 우리가 원하는 값을 찾아간다는 입장에서 보면 인덱스 개념이라 할 수 있다.

우리가 정의한 해쉬함수를 경유하여 어떤값이 저장된 위치를 찾을 수 있도록 저장하는 기법으로 해쉬 클러스터에 생성되는 테이블의 로우들이 저장될 위치를 결정하는 방법을 정의하는 것이다. 

2장 인덱스의 유형과 특징
인덱스는 목차나 색인의 개념이다. 일반적으로 인덱스를 키(key) 라는 생각으로 접근을 하고 있다. 엄밀한 의미에서 이들의 개념은 확실히 다르다. 인덱스는 단순하게 색인이라는 개념에 앞서 옵티마이져가 실행계획을 수립할 때 최적의 경로를 찾도록 하는 '전략적 요소'라는 시각에서 접근해야 한다.